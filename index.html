<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Drone Academy - 15 Niveaux</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @keyframes bounce-in { 0% { transform: scale(0.9); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
        .animate-bounce-in { animation: bounce-in 0.3s ease-out forwards; }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        /* EmpÃªcher le zoom double-tap sur tablette */
        button { touch-action: manipulation; }
    </style>
</head>
<body class="flex flex-col h-screen bg-slate-100 font-sans select-none overflow-hidden text-slate-800">

    <!-- En-tÃªte -->
    <header class="bg-indigo-600 text-white p-3 md:p-4 shadow-lg flex justify-between items-center z-20 shrink-0">
        <div class="flex items-center gap-2 md:gap-3">
            <div class="bg-white p-2 rounded-full text-indigo-600 shadow-sm">
                <i data-lucide="rocket" class="w-5 h-5 md:w-6 md:h-6"></i>
            </div>
            <h1 class="text-lg md:text-2xl font-bold tracking-tight">Drone Academy</h1>
        </div>
        <div class="flex items-center gap-2 md:gap-4">
            <div class="bg-indigo-800 px-3 py-1 rounded text-xs font-mono opacity-90 border border-indigo-500">
                NIVEAU <span id="level-indicator" class="text-white font-bold text-lg">1</span>/15
            </div>
            <div id="mission-badge" class="hidden sm:flex items-center gap-3 px-4 py-2 rounded-lg transition-colors bg-indigo-800 text-indigo-100">
                <i data-lucide="trophy" id="trophy-icon" class="w-5 h-5 opacity-70"></i>
                <span id="mission-text" class="font-bold text-sm md:text-base">Objectif : L'Ã©toile</span>
            </div>
        </div>
    </header>

    <div class="flex flex-1 overflow-hidden">
        
        <!-- Palette (Desktop/Tablet Large) -->
        <div class="w-64 bg-slate-200 p-4 overflow-y-auto border-r border-slate-300 shadow-inner hidden md:block shrink-0">
            <h2 class="text-slate-500 font-bold uppercase text-xs mb-4 tracking-wider">Commandes</h2>
            <div id="desktop-tools" class="space-y-3"></div>
            <div class="mt-8 p-4 bg-white/50 rounded-xl border border-white text-sm text-slate-600">
                <p class="font-bold mb-1 text-indigo-600">ðŸ’¡ Astuce :</p>
                Ã‰vite les obstacles gris.<br>
                N'oublie pas de <span class="font-bold text-green-600">DÃ©coller</span> !
            </div>
        </div>

        <!-- Zone de code -->
        <div class="flex-1 bg-white p-2 md:p-4 flex flex-col relative min-w-0">
            <!-- Palette Mobile -->
            <div id="mobile-tools" class="md:hidden flex gap-2 overflow-x-auto pb-3 mb-2 shrink-0 no-scrollbar touch-pan-x"></div>

            <div class="flex justify-between items-center mb-2 border-b pb-2 shrink-0">
                <h2 class="text-slate-500 font-bold uppercase text-xs tracking-wider">Ton Programme</h2>
                <button onclick="clearProgram()" class="text-red-400 hover:text-red-600 hover:bg-red-50 px-3 py-2 rounded-lg transition-colors text-sm font-bold flex items-center gap-1 active:bg-red-100">
                    <i data-lucide="trash-2" class="w-4 h-4"></i> <span class="hidden sm:inline">Recommencer</span>
                </button>
            </div>

            <div id="program-container" class="flex-1 overflow-y-auto bg-slate-50 rounded-xl border-2 border-dashed border-slate-200 p-4 content-start relative touch-pan-y">
                <div id="empty-state" class="absolute inset-0 flex flex-col items-center justify-center text-slate-400 text-center p-4 pointer-events-none">
                    <div class="mb-4 p-4 bg-slate-100 rounded-full">
                        <i data-lucide="corner-down-left" class="w-8 h-8 opacity-50"></i>
                    </div>
                    <p class="font-bold text-lg">Zone de programmation</p>
                    <p class="text-sm">Ajoute des blocs ici.</p>
                </div>
                <div id="program-list" class="space-y-2 hidden"></div>
                <div class="h-24"></div>
            </div>
        </div>

        <!-- Simulateur -->
        <div class="w-[300px] lg:w-[420px] bg-slate-100 p-4 flex flex-col border-l border-slate-300 shadow-xl z-10 shrink-0">
            
            <div class="bg-white rounded-2xl shadow-sm border border-slate-200 p-2 mb-4 flex-1 flex flex-col items-center justify-center relative overflow-hidden">
                
                <!-- ContrÃ´les de Vue -->
                <div class="absolute top-3 left-3 z-10 flex bg-white/90 backdrop-blur rounded-lg shadow-sm border p-1 gap-1">
                    <button onclick="setViewMode('TOP')" id="btn-view-top" class="p-2 rounded flex items-center gap-1 text-[10px] font-bold uppercase tracking-wider transition-colors bg-indigo-100 text-indigo-700">
                        <i data-lucide="grid-3x3" class="w-3 h-3"></i> 2D
                    </button>
                    <button onclick="setViewMode('ISO')" id="btn-view-iso" class="p-2 rounded flex items-center gap-1 text-[10px] font-bold uppercase tracking-wider transition-colors text-slate-400 hover:text-slate-600">
                        <i data-lucide="box" class="w-3 h-3"></i> 3D
                    </button>
                </div>

                <canvas id="simCanvas" width="400" height="400" class="rounded-lg border bg-slate-50 shadow-inner w-full h-auto object-contain max-h-full"></canvas>
                
                <div id="message-container" class="absolute bottom-4 left-4 right-4 text-center transition-all duration-300 transform translate-y-4 opacity-0">
                    <div id="message-box" class="inline-block px-4 py-2 rounded-xl text-sm font-bold shadow-lg border-2 bg-white border-blue-100 text-blue-600">
                        Bienvenue !
                    </div>
                </div>
            </div>

            <div class="grid grid-cols-2 gap-3 shrink-0">
                <button id="btn-run" onclick="runProgram()" class="py-4 rounded-xl font-bold text-white shadow-lg flex items-center justify-center gap-2 transition-all transform active:scale-95 border-b-4 bg-slate-300 border-slate-400 cursor-not-allowed text-slate-500" disabled>
                    <i data-lucide="play" class="w-6 h-6"></i>
                    <span id="btn-run-text">LANCER</span>
                </button>
                
                <button onclick="resetSimulation()" class="bg-white border-b-4 border-slate-200 text-slate-600 py-4 rounded-xl font-bold hover:bg-slate-50 hover:border-slate-300 transition-colors flex items-center justify-center gap-2 active:scale-95 active:bg-slate-100">
                    <i data-lucide="rotate-ccw" class="w-5 h-5"></i>
                    Reset
                </button>
            </div>
        </div>

    </div>

    <!-- Modal Level Success -->
    <div id="modal-success" class="hidden fixed inset-0 bg-black/60 flex items-center justify-center z-50 backdrop-blur-sm p-4">
        <div class="bg-white p-6 md:p-8 rounded-3xl shadow-2xl max-w-sm w-full text-center border-4 border-yellow-400 relative overflow-hidden animate-bounce-in">
           <div class="absolute top-0 left-0 w-full h-2 bg-yellow-400"></div>
           <div class="inline-flex p-5 bg-yellow-100 rounded-full mb-4 text-yellow-500 shadow-inner ring-4 ring-yellow-50">
               <i data-lucide="trophy" class="w-12 h-12"></i>
           </div>
           <h2 class="text-3xl font-bold text-slate-800 mb-2">Niveau RÃ©ussi !</h2>
           <p class="text-slate-500 mb-8 font-medium">Excellent travail pilote.</p>
           <button onclick="nextLevel()" class="bg-indigo-600 text-white px-8 py-4 rounded-xl font-bold shadow-lg hover:bg-indigo-700 hover:scale-105 transition-all w-full border-b-4 border-indigo-800">
             Niveau Suivant
           </button>
        </div>
    </div>

    <!-- Modal Game Over (Victory) -->
    <div id="modal-victory" class="hidden fixed inset-0 bg-black/80 flex items-center justify-center z-50 backdrop-blur-md p-4">
        <div class="bg-white p-8 rounded-3xl shadow-2xl max-w-md w-full text-center border-4 border-purple-500 relative overflow-hidden animate-bounce-in">
           <div class="inline-flex p-6 bg-purple-100 rounded-full mb-6 text-purple-600 shadow-inner ring-4 ring-purple-50">
               <i data-lucide="crown" class="w-16 h-16 animate-pulse"></i>
           </div>
           <h2 class="text-4xl font-bold text-purple-900 mb-4">CHAMPION !</h2>
           <p class="text-slate-600 mb-8 text-lg">Tu as maÃ®trisÃ© les 15 niveaux. Tu es prÃªt pour le pilotage rÃ©el !</p>
           <button onclick="location.reload()" class="bg-purple-600 text-white px-8 py-4 rounded-xl font-bold shadow-lg hover:bg-purple-700 hover:scale-105 transition-all w-full border-b-4 border-purple-800">
             Recommencer l'aventure
           </button>
        </div>
    </div>

    <script>
        // --- Configuration ---
        const CANVAS_SIZE = 400;
        const GRID_CELL = 50;
        const GRID_OFFSET = GRID_CELL / 2; // Pour centrer (25px)
        
        // --- Les 15 Niveaux ---
        // obstacles: Array of [gridX, gridY]
        const LEVELS = [
            // PHASE 1 : BASES (1-5)
            { id: 1, start: [1, 4, 90], target: [4, 4], obstacles: [], hint: "Va tout droit !" },
            { id: 2, start: [1, 4, 90], target: [6, 4], obstacles: [], hint: "Un peu plus loin..." },
            { id: 3, start: [2, 6, 0], target: [2, 2], obstacles: [], hint: "Attention au sens du drone." },
            { id: 4, start: [1, 6, 90], target: [1, 3], obstacles: [], hint: "Utilise 'Tourner Gauche'." },
            { id: 5, start: [1, 1, 90], target: [4, 4], obstacles: [], hint: "L'escalier (Avancer, Tourner, Avancer...)" },
            
            // PHASE 2 : OBSTACLES SIMPLES (6-10)
            { id: 6, start: [1, 3, 90], target: [5, 3], obstacles: [[3, 3]], hint: "Contourne le rocher !" },
            { id: 7, start: [1, 1, 90], target: [1, 6], obstacles: [[1, 3], [1, 4]], hint: "Le chemin direct est bloquÃ©." },
            { id: 8, start: [3, 6, 0], target: [3, 2], obstacles: [[3, 4]], hint: "Fais un petit dÃ©tour." },
            { id: 9, start: [1, 1, 90], target: [6, 6], obstacles: [[2, 2], [3, 3], [4, 4], [5, 5]], hint: "Ne fonce pas dans la diagonale !" },
            { id: 10, start: [1, 4, 90], target: [6, 4], obstacles: [[3, 3], [3, 4], [3, 5]], hint: "Un mur te barre la route." },

            // PHASE 3 : EXPERT (11-15)
            { id: 11, start: [1, 1, 90], target: [6, 1], obstacles: [[2, 1], [3, 1], [4, 1], [5, 1], [3, 2], [3, 0]], hint: "Quel labyrinthe !" },
            { id: 12, start: [3, 3, 0], target: [3, 4], obstacles: [[3, 2], [2, 3], [4, 3], [2, 4], [4, 4], [3, 5]], hint: "Tu es encerclÃ©, il faut sortir." },
            { id: 13, start: [0, 7, 90], target: [7, 0], obstacles: [[1, 6], [2, 5], [3, 4], [4, 3], [5, 2], [6, 1]], hint: "Le passage est Ã©troit." },
            { id: 14, start: [1, 4, 90], target: [6, 4], obstacles: [[2, 4], [4, 4], [2, 3], [4, 5], [3, 1], [3, 7]], hint: "Zig-zag obligatoire." },
            { id: 15, start: [0, 0, 90], target: [7, 7], obstacles: [[1, 0], [0, 1], [2, 2], [3, 3], [4, 4], [5, 5], [6, 6], [7, 6], [6, 7], [1, 2], [2, 1]], hint: "Le dÃ©fi final. Bonne chance !" }
        ];

        const BLOCK_TYPES = {
            TAKEOFF: { id: 'TAKEOFF', label: 'DÃ©coller', color: 'bg-green-500', icon: 'rocket', action: (d) => ({ ...d, isFlying: true, altitude: 60 }) },
            FORWARD: { id: 'FORWARD', label: 'Avancer', color: 'bg-blue-500', icon: 'arrow-up', action: (d) => {
                const step = GRID_CELL; 
                const rad = (d.rotation * Math.PI) / 180;
                let nx = d.x + Math.sin(rad) * step;
                let ny = d.y - Math.cos(rad) * step;
                return { ...d, x: Math.round(nx), y: Math.round(ny) };
            }},
            LEFT: { id: 'LEFT', label: 'Tourner Gauche', color: 'bg-yellow-500', icon: 'arrow-left', action: (d) => ({ ...d, rotation: d.rotation - 90 }) },
            RIGHT: { id: 'RIGHT', label: 'Tourner Droite', color: 'bg-yellow-500', icon: 'arrow-right', action: (d) => ({ ...d, rotation: d.rotation + 90 }) },
            LAND: { id: 'LAND', label: 'Atterrir', color: 'bg-red-500', icon: 'corner-down-left', action: (d) => ({ ...d, isFlying: false, altitude: 0 }) },
        };

        // --- Ã‰tat Global ---
        let state = {
            levelIndex: 0,
            program: [],
            isPlaying: false,
            activeBlockIndex: -1,
            missionComplete: false,
            viewMode: 'TOP',
            drone: { x: 0, y: 0, rotation: 0, isFlying: false, altitude: 0 },
            path: [],
            target: { x: 0, y: 0 },
            obstacles: []
        };

        window.onload = () => {
            initTools();
            loadLevel(0);
            loop(); 
        };

        function initTools() {
            const desk = document.getElementById('desktop-tools');
            const mob = document.getElementById('mobile-tools');
            Object.values(BLOCK_TYPES).forEach(type => {
                // Desktop
                const btn = document.createElement('button');
                btn.className = `${type.color} text-white font-bold py-3 px-4 rounded-xl shadow-lg transform active:scale-95 transition-all flex items-center gap-2 w-full mb-3 border-b-4 border-black/20 hover:brightness-110`;
                btn.innerHTML = `<i data-lucide="${type.icon}" class="w-5 h-5"></i><span>${type.label}</span>`;
                btn.onclick = () => addBlock(type.id);
                desk.appendChild(btn);
                // Mobile
                const btnMob = document.createElement('button');
                btnMob.className = `${type.color} text-white p-3 rounded-xl shadow active:scale-95 shrink-0 flex flex-col items-center gap-1 w-16`;
                btnMob.innerHTML = `<i data-lucide="${type.icon}" class="w-5 h-5"></i><span class="text-[10px] font-bold truncate w-full text-center">${type.label}</span>`;
                btnMob.onclick = () => addBlock(type.id);
                mob.appendChild(btnMob);
            });
            lucide.createIcons();
        }

        // --- Gestion des Niveaux ---
        function loadLevel(idx) {
            if(idx >= LEVELS.length) {
                document.getElementById('modal-victory').classList.remove('hidden');
                return;
            }
            state.levelIndex = idx;
            const lvl = LEVELS[idx];
            
            const sx = lvl.start[0] * GRID_CELL + GRID_OFFSET;
            const sy = lvl.start[1] * GRID_CELL + GRID_OFFSET;
            const tx = lvl.target[0] * GRID_CELL + GRID_OFFSET;
            const ty = lvl.target[1] * GRID_CELL + GRID_OFFSET;

            // Conversion obstacles grille -> pixels (pour affichage et collision)
            // On stocke les indices de grille pour collision simple
            state.obstacles = lvl.obstacles.map(o => ({ gx: o[0], gy: o[1], x: o[0]*GRID_CELL+GRID_OFFSET, y: o[1]*GRID_CELL+GRID_OFFSET }));

            state.drone = { x: sx, y: sy, rotation: lvl.start[2], isFlying: false, altitude: 0 };
            state.target = { x: tx, y: ty };
            state.path = [{ x: sx, y: sy }];
            state.activeBlockIndex = -1;
            state.isPlaying = false;
            state.missionComplete = false;
            state.viewMode = 'TOP';

            document.getElementById('level-indicator').innerText = idx + 1;
            document.getElementById('modal-success').classList.add('hidden');
            
            updateUI();
            updateProgramUI();
            setViewMode('TOP');
            showMessage(`Niveau ${idx+1}: ${lvl.hint}`, 'info');
        }

        function resetSimulation() {
            const lvl = LEVELS[state.levelIndex];
            const sx = lvl.start[0] * GRID_CELL + GRID_OFFSET;
            const sy = lvl.start[1] * GRID_CELL + GRID_OFFSET;
            
            state.drone = { x: sx, y: sy, rotation: lvl.start[2], isFlying: false, altitude: 0 };
            state.path = [{ x: sx, y: sy }];
            state.activeBlockIndex = -1;
            state.isPlaying = false;
            state.missionComplete = false;
            setViewMode('TOP');
            updateUI();
            updateProgramUI();
        }

        function nextLevel() {
            state.program = []; 
            loadLevel(state.levelIndex + 1);
        }

        function addBlock(typeId) {
            if (state.isPlaying) return;
            state.program.push({ type: typeId, id: Date.now() + Math.random() });
            updateProgramUI();
        }

        function deleteBlock(index) {
            if (state.isPlaying) return;
            state.program.splice(index, 1);
            updateProgramUI();
        }

        function clearProgram() {
            if (state.isPlaying) return;
            state.program = [];
            state.activeBlockIndex = -1;
            updateProgramUI();
        }

        function setViewMode(mode) {
            state.viewMode = mode;
            const btnTop = document.getElementById('btn-view-top');
            const btnIso = document.getElementById('btn-view-iso');
            if(mode === 'TOP') {
                btnTop.className = "p-2 rounded flex items-center gap-1 text-[10px] font-bold uppercase tracking-wider transition-colors bg-indigo-100 text-indigo-700";
                btnIso.className = "p-2 rounded flex items-center gap-1 text-[10px] font-bold uppercase tracking-wider transition-colors text-slate-400 hover:text-slate-600";
            } else {
                btnTop.className = "p-2 rounded flex items-center gap-1 text-[10px] font-bold uppercase tracking-wider transition-colors text-slate-400 hover:text-slate-600";
                btnIso.className = "p-2 rounded flex items-center gap-1 text-[10px] font-bold uppercase tracking-wider transition-colors bg-indigo-100 text-indigo-700";
            }
        }

        async function runProgram() {
            if (state.program.length === 0) {
                showMessage("Ajoute des blocs d'abord !", 'error');
                return;
            }
            
            setViewMode('ISO');
            state.isPlaying = true;
            showMessage("DÃ©collage...", 'info');
            updateUI();

            let currentDrone = { ...state.drone };

            try {
                for (let i = 0; i < state.program.length; i++) {
                    state.activeBlockIndex = i;
                    updateProgramUI();
                    
                    const blockType = BLOCK_TYPES[state.program[i].type];

                    if (!currentDrone.isFlying && blockType.id !== 'TAKEOFF') {
                        showMessage("ERREUR: DÃ©colle d'abord !", 'error');
                        state.isPlaying = false;
                        updateUI();
                        return;
                    }

                    const nextDrone = blockType.action(currentDrone);
                    
                    // --- COLLISION DETECTION ---
                    // 1. Check Bounds
                    if (nextDrone.x < 0 || nextDrone.x > CANVAS_SIZE || nextDrone.y < 0 || nextDrone.y > CANVAS_SIZE) {
                         // Animate crash to the edge
                         await animateDrone(currentDrone, nextDrone);
                         showMessage("Alerte ! Tu sors de la zone !", 'error');
                         state.isPlaying = false;
                         updateUI();
                         return;
                    }

                    // 2. Check Obstacles
                    // Convert pixel pos back to grid index approx to check collision
                    const ngx = Math.floor(nextDrone.x / GRID_CELL);
                    const ngy = Math.floor(nextDrone.y / GRID_CELL);
                    
                    const hitObstacle = state.obstacles.find(o => o.gx === ngx && o.gy === ngy);
                    if (hitObstacle) {
                         await animateDrone(currentDrone, nextDrone); // Move to the crash site
                         state.drone = nextDrone; // Update state to show crash position
                         showMessage("BOUM ! Attention au rocher !", 'error');
                         state.isPlaying = false;
                         updateUI();
                         return;
                    }

                    await animateDrone(currentDrone, nextDrone);
                    
                    currentDrone = nextDrone;
                    state.drone = currentDrone;
                    
                    const lastP = state.path[state.path.length-1];
                    if (currentDrone.x !== lastP.x || currentDrone.y !== lastP.y) {
                        state.path.push({x: currentDrone.x, y: currentDrone.y});
                    }

                    await new Promise(r => setTimeout(r, 400));
                }
                checkWin(currentDrone);
            } catch (e) {
                console.error(e);
            } finally {
                state.isPlaying = false;
                state.activeBlockIndex = -1;
                updateUI();
                updateProgramUI();
            }
        }

        function animateDrone(start, end) {
            return new Promise(resolve => {
                const duration = 600;
                let startTime = null;
                function step(timestamp) {
                    if (!startTime) startTime = timestamp;
                    const progress = Math.min((timestamp - startTime) / duration, 1);
                    const p = progress < .5 ? 2*progress*progress : -1+(4-2*progress)*progress;
                    
                    state.drone = {
                        x: start.x + (end.x - start.x) * p,
                        y: start.y + (end.y - start.y) * p,
                        rotation: start.rotation + (end.rotation - start.rotation) * p,
                        altitude: start.altitude + (end.altitude - start.altitude) * p,
                        isFlying: end.isFlying
                    };
                    
                    if (progress < 1) requestAnimationFrame(step);
                    else resolve();
                }
                requestAnimationFrame(step);
            });
        }

        function checkWin(finalDrone) {
            const dist = Math.sqrt(Math.pow(finalDrone.x - state.target.x, 2) + Math.pow(finalDrone.y - state.target.y, 2));
            if (dist < 25) {
                if (!finalDrone.isFlying || finalDrone.altitude < 10) {
                    state.missionComplete = true;
                    showMessage("BRAVO !", 'success');
                    updateUI();
                    setTimeout(() => document.getElementById('modal-success').classList.remove('hidden'), 800);
                } else {
                    showMessage("Atterris pour valider !", 'warning');
                }
            } else {
                showMessage("Pas tout Ã  fait... VÃ©rifie ton code.", 'info');
            }
        }

        function updateUI() {
            const btnRun = document.getElementById('btn-run');
            const btnText = document.getElementById('btn-run-text');
            if (state.isPlaying || state.program.length === 0) {
                btnRun.className = "py-4 rounded-xl font-bold text-white shadow-lg flex items-center justify-center gap-2 transition-all transform active:scale-95 border-b-4 bg-slate-300 border-slate-400 cursor-not-allowed text-slate-500";
                btnRun.disabled = true;
                btnText.innerText = state.isPlaying ? "En vol..." : "LANCER";
            } else {
                btnRun.className = "py-4 rounded-xl font-bold text-white shadow-lg flex items-center justify-center gap-2 transition-all transform active:scale-95 border-b-4 bg-green-500 border-green-700 hover:bg-green-600 hover:shadow-green-500/30";
                btnRun.disabled = false;
                btnText.innerText = "LANCER";
            }
            
            const badge = document.getElementById('mission-badge');
            const trophy = document.getElementById('trophy-icon');
            if (state.missionComplete) {
                badge.classList.remove('bg-indigo-800', 'text-indigo-100');
                badge.classList.add('bg-yellow-400', 'text-yellow-900');
                trophy.classList.add('animate-bounce');
            } else {
                badge.classList.add('bg-indigo-800', 'text-indigo-100');
                badge.classList.remove('bg-yellow-400', 'text-yellow-900');
                trophy.classList.remove('animate-bounce');
            }
        }

        function updateProgramUI() {
            const container = document.getElementById('program-list');
            const empty = document.getElementById('empty-state');
            
            if (state.program.length === 0) {
                container.classList.add('hidden');
                empty.classList.remove('hidden');
            } else {
                container.classList.remove('hidden');
                empty.classList.add('hidden');
                container.innerHTML = '';
                
                state.program.forEach((block, idx) => {
                    const type = BLOCK_TYPES[block.type];
                    const isActive = idx === state.activeBlockIndex;
                    const div = document.createElement('div');
                    
                    div.className = `relative group ${type.color} text-white p-3 rounded-lg shadow-md flex items-center gap-2 border-l-8 transition-all duration-200 ${isActive ? 'border-white scale-105 ring-4 ring-yellow-400 z-10' : 'border-black/20'}`;
                    div.innerHTML = `
                        <div class="font-mono text-xs opacity-50 absolute top-1 right-2">${idx + 1}</div>
                        <i data-lucide="${type.icon}" class="w-4 h-4"></i>
                        <span class="font-bold">${type.label}</span>
                    `;
                    if (!isActive && !state.isPlaying) {
                        const delBtn = document.createElement('button');
                        delBtn.className = "ml-auto bg-black/20 hover:bg-black/40 p-1 rounded text-white opacity-0 group-hover:opacity-100 transition-opacity";
                        delBtn.innerHTML = `<i data-lucide="x" class="w-3 h-3"></i>`;
                        delBtn.onclick = (e) => { e.stopPropagation(); deleteBlock(idx); };
                        div.appendChild(delBtn);
                    }
                    container.appendChild(div);
                });
                lucide.createIcons();
            }
            updateUI();
        }

        function showMessage(text, type) {
            const box = document.getElementById('message-box');
            const cont = document.getElementById('message-container');
            box.innerText = text;
            if (type === 'error') box.className = "inline-block px-4 py-2 rounded-xl text-sm font-bold shadow-lg border-2 bg-red-50 border-red-100 text-red-600 animate-shake";
            else if (type === 'success') box.className = "inline-block px-4 py-2 rounded-xl text-sm font-bold shadow-lg border-2 bg-green-50 border-green-100 text-green-600 scale-110";
            else box.className = "inline-block px-4 py-2 rounded-xl text-sm font-bold shadow-lg border-2 bg-white border-blue-100 text-blue-600";
            cont.classList.remove('translate-y-4', 'opacity-0');
            cont.classList.add('translate-y-0', 'opacity-100');
        }

        // --- MOTEUR GRAPHIQUE ---
        
        function loop() {
            const ctx = document.getElementById('simCanvas').getContext('2d');
            ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            if (state.viewMode === 'TOP') drawTop(ctx);
            else drawIso(ctx); 
            requestAnimationFrame(loop);
        }

        // Helper pour dessiner le drone
        function drawDrone2D(ctx, x, y, rot, alt) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate((rot * Math.PI)/180);
            const scale = 1 + (alt / 400); 
            ctx.scale(scale, scale);

            ctx.fillStyle = '#2563eb';
            ctx.beginPath();
            ctx.roundRect(-15, -15, 30, 30, 8);
            ctx.fill();

            ctx.fillStyle = '#bfdbfe';
            [[-15,-15],[15,-15],[15,15],[-15,15]].forEach(([dx,dy], idx) => {
                ctx.beginPath();
                const r = state.drone.isFlying ? 7 + Math.sin(Date.now()/50+idx) : 7;
                ctx.arc(dx, dy, r, 0, Math.PI*2); ctx.fill();
                ctx.strokeStyle = '#1d4ed8'; ctx.lineWidth = 1; ctx.stroke();
            });

            ctx.fillStyle = 'white';
            ctx.beginPath(); ctx.moveTo(0,-10); ctx.lineTo(-5,-2); ctx.lineTo(5,-2); ctx.fill();
            ctx.restore();
        }

        function drawTop(ctx) {
            // Fond
            ctx.strokeStyle = '#e2e8f0'; ctx.lineWidth = 1;
            for(let i=0; i<=CANVAS_SIZE; i+=GRID_CELL) {
                ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,CANVAS_SIZE); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0,i); ctx.lineTo(CANVAS_SIZE,i); ctx.stroke();
            }
            
            // OBSTACLES (VUE DE DESSUS)
            ctx.fillStyle = '#94a3b8'; // Slate 400
            state.obstacles.forEach(o => {
                ctx.beginPath();
                ctx.roundRect(o.x - 20, o.y - 20, 40, 40, 4);
                ctx.fill();
                // DÃ©tail rocher
                ctx.fillStyle = '#64748b';
                ctx.beginPath(); ctx.arc(o.x-5, o.y-5, 5, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#94a3b8';
            });

            // Cible
            ctx.save();
            ctx.translate(state.target.x, state.target.y);
            ctx.fillStyle = '#fbbf24'; ctx.shadowColor = '#f59e0b'; ctx.shadowBlur = 10;
            ctx.beginPath(); ctx.arc(0,0,12,0,Math.PI*2); ctx.fill();
            ctx.strokeStyle = '#f59e0b'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(0,0,18 + Math.sin(Date.now()/200)*2, 0, Math.PI*2); ctx.stroke();
            ctx.restore();

            // Trace
            if(state.path.length > 1) {
                ctx.strokeStyle = '#93c5fd'; ctx.lineWidth = 3; ctx.setLineDash([5,5]);
                ctx.beginPath(); ctx.moveTo(state.path[0].x, state.path[0].y);
                for(let i=1; i<state.path.length; i++) ctx.lineTo(state.path[i].x, state.path[i].y);
                ctx.lineTo(state.drone.x, state.drone.y); ctx.stroke(); ctx.setLineDash([]);
            }

            // Ombre Drone
            ctx.save(); 
            ctx.translate(state.drone.x, state.drone.y);
            ctx.rotate((state.drone.rotation * Math.PI)/180);
            const shadowScale = Math.max(0.5, 1 - (state.drone.altitude/200));
            ctx.scale(shadowScale, shadowScale); 
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.beginPath(); ctx.roundRect(-15, -15, 30, 30, 8); ctx.fill();
            ctx.restore();

            // Drone
            const viewY = state.drone.y - (state.drone.altitude * 0.5);
            drawDrone2D(ctx, state.drone.x, viewY, state.drone.rotation, state.drone.altitude);
        }

        // --- VUE ISOMETRIQUE ---
        function drawIso(ctx) {
            const originX = 200; 
            const originY = 50;  
            const isoW = 0.8;    
            const isoH = 0.4;    

            const toIso = (x, y, z) => {
                return {
                    x: (x - y) * isoW + originX,
                    y: (x + y) * isoH + originY - z
                };
            };

            // Sol
            ctx.lineWidth = 1;
            ctx.strokeStyle = '#cbd5e1';
            for(let x=0; x<=CANVAS_SIZE; x+=GRID_CELL) {
                const p1 = toIso(x, 0, 0); const p2 = toIso(x, CANVAS_SIZE, 0);
                ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
            }
            for(let y=0; y<=CANVAS_SIZE; y+=GRID_CELL) {
                const p1 = toIso(0, y, 0); const p2 = toIso(CANVAS_SIZE, y, 0);
                ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
            }

            // OBSTACLES (VUE ISO - CUBES)
            // On trie les objets par profondeur (y approximatif) pour le painter's algorithm si besoin
            // Ici simple : on dessine tout le sol/obstacles avant le drone.
            state.obstacles.forEach(o => {
                const z = 0; const h = 25; // Hauteur obstacle
                const base = toIso(o.x, o.y, 0);
                const top = toIso(o.x, o.y, h);
                
                // Ombre au sol
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                ctx.beginPath(); ctx.ellipse(base.x, base.y, 15, 8, 0, 0, Math.PI*2); ctx.fill();

                // Corps (Cube simplifiÃ© - juste le top et face)
                ctx.fillStyle = '#64748b'; // Top color
                ctx.beginPath();
                // Face approximative pour effet 3D simple
                ctx.moveTo(base.x-10, base.y); ctx.lineTo(base.x+10, base.y);
                ctx.lineTo(top.x+10, top.y); ctx.lineTo(top.x-10, top.y);
                ctx.fill();
                
                // Top
                ctx.fillStyle = '#94a3b8';
                ctx.beginPath(); ctx.ellipse(top.x, top.y, 12, 6, 0, 0, Math.PI*2); ctx.fill();
            });

            // Cible
            const tPos = toIso(state.target.x, state.target.y, 5 + Math.sin(Date.now()/300)*5);
            const tShadow = toIso(state.target.x, state.target.y, 0);
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.beginPath(); ctx.ellipse(tShadow.x, tShadow.y, 10, 5, 0, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#fbbf24'; 
            ctx.beginPath(); ctx.arc(tPos.x, tPos.y, 8, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = '#f59e0b'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(tPos.x, tPos.y, 12, 0, Math.PI*2); ctx.stroke();

            // Trace
            if(state.path.length > 1) {
                ctx.strokeStyle = '#3b82f6'; ctx.lineWidth = 2; ctx.globalAlpha = 0.5;
                ctx.beginPath();
                const start = toIso(state.path[0].x, state.path[0].y, 0);
                ctx.moveTo(start.x, start.y);
                for(let i=1; i<state.path.length; i++) {
                    const p = toIso(state.path[i].x, state.path[i].y, 0);
                    ctx.lineTo(p.x, p.y);
                }
                const currBase = toIso(state.drone.x, state.drone.y, 0);
                ctx.lineTo(currBase.x, currBase.y);
                ctx.stroke();
                ctx.globalAlpha = 1.0;
            }

            // Drone
            const dX = state.drone.x;
            const dY = state.drone.y;
            const dZ = state.drone.altitude;
            const dIso = toIso(dX, dY, dZ);
            const dShadow = toIso(dX, dY, 0);

            if(dZ > 0) {
                ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.setLineDash([2,2]); ctx.lineWidth=1;
                ctx.beginPath(); ctx.moveTo(dShadow.x, dShadow.y); ctx.lineTo(dIso.x, dIso.y); ctx.stroke();
                ctx.setLineDash([]);
            }

            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            const sRadius = Math.max(5, 15 - dZ/20);
            ctx.beginPath(); ctx.ellipse(dShadow.x, dShadow.y, sRadius, sRadius*0.5, 0, 0, Math.PI*2); ctx.fill();

            ctx.save();
            ctx.translate(dIso.x, dIso.y);
            ctx.fillStyle = '#2563eb';
            ctx.beginPath(); ctx.ellipse(0, 0, 15, 8, 0, 0, Math.PI*2); ctx.fill();
            
            ctx.fillStyle = '#bfdbfe';
            const propOffsets = [{x:-12, y:-6}, {x:12, y:-6}, {x:-12, y:6}, {x:12, y:6}];
            const spin = state.drone.isFlying ? Math.sin(Date.now())*2 : 0;
            propOffsets.forEach(po => {
                ctx.beginPath(); ctx.ellipse(po.x, po.y, 6+spin, 3, 0, 0, Math.PI*2); ctx.fill();
            });

            ctx.fillStyle = state.drone.isFlying ? '#10b981' : '#ef4444';
            ctx.beginPath(); ctx.arc(0, -2, 3, 0, Math.PI*2); ctx.fill();
            ctx.restore();
        }

    </script>
</body>
</html>
